2 数据类型
  基本(值)类型
  String:任意字符串
  Number:任意数字
  boolean: true/false
  undefined:undefined
  null:null
  对象 引用
  Object:任意对象
  Function:一种特别的对象 可以执行
  Array:一种特别的对象 数值下标,内部数据

  判断类型
  typeof 返回数据类型的字符串表达 undefined 数值 字符串 布尔值 function  不能判断null与object object与array
  instanceof 判断对象的具体类型  a instanceof Object a是不是Object实例
  === 可以判断 undefined null

 ()调用函数
 
3 相关问题
 undefined代表定义未赋值
 null 定义赋值了为null 表明将要赋值为对象

4 数据 变量 内存

5 相关问题1
 var a= xxx 
 基本数据就是保存这个数据
 对象就是保存对象的地址值

 两个引用变量指向同一个对象，通过一个变量修改对象内部数据，
 另一个变量看到的是修改之后的数据
 var a={name:'xx'}
 var b=a 
 b.age=12
 a.age  =12

 两个引用变量指向同一个对象，让其中应该引用变量指向另一个对象，
 另一个引用变量仍然指向前应该对象
         var a={age:12}
        var b=a
        a={age:13}
        function fun(obj){
            obj={age:15}
        }
        fun(a)
        console.log(a.age);13

6 相关问题2
 js调用函数时传递变量参数时，是值传递

js管理内存
 1内存生命周期
 分配小内存空间，得到它的使用权
 存储数据，可以反复进行操作
 释放小内存空间

 2释放内存
 局部变量 函数指向完自动释放
 对象 成为垃圾对象==>垃圾回收器回收

7 高级 对象 
 1 什么是对象
 多个数据的封装体
 用来保存多个数据容器
 一个对象代表现实的一个事物

 2为什么用对象
 统一管理多个数据

 3对象的组成
 属性 属性名(字符串)和属性值
 方法 一种特别的属性 属性是函数

 4.访问对象内部数据
 xx.属性名  xx.方法名()
 属性名包含特殊字符不能用普通方式 xx['xx']='xx'
 变量名不确定
 var xx='xx'
 var xxx='xxx'
 xxxx[xx]=xxx

8 函数 
 1什么是函数

 2为什么要用函数
 提高代码复用
 
 3如何定义函数
 函数声明
 表达式
 
 function fn1 (){}
 var fn2=function(){}

 4如何调用 执行 函数
 xx() 直接调用
 xx.xxx() 通过对象调用
 new xx() new调用
 xx.call/apply(obj)=obj.xx() 可以让一个函数成为指定任意对象的方法进行调用

9 回调函数
 1什么是回调函数
 你定义的
 你没有调
 但最终执行了

 2常见
 dom事件回调函数
 定时器回调
 ajax请求
 生命周期

10 IIFE
 1理解
 立即执行调用函数
 (function(){})()匿名函数自调用

 2作用
 隐藏实现
 不会污染外部命名空间

 $().test()
 是一个函数 执行后返回的是一个对象

11 this
 1 this是什么
 任何函数本质上都是对象来调用
 所有函数内部都有一个变量this
 它的值是调用函数的当前对象

 2如何确定this
 test() window
 p.test() p
 new test() 新创建的对象
 p.call(obj) obj


 1. 以函数的形式调用时，this永远都是window
 2. 以方法的形式调用时，this就是调用方法的对象
 3. 以构造函数的形式调用时，this就是新创建的对象
 4. 使用call和apply调用时，this就是指定的那个对象
 5. 在全局作用域中this代表window

12 分号
 1js一条语句的后面可以不加分号

 3 小括号开头前的一条语句
    中括号开头的前一条语句
    加分号

  4 在行首加分号

14 复习
 
15 prototype
 1函数prototype属性 
 默认指向一个object空对象 (即 原型对象)
 原型对象中有一个属性constructor。指向函数对象

 2 给原型对象添加属性(一般是方法)
 作用 函数的所有实例对象自动拥有原型中的属性 方法  实例对象可以被访问
 function Fun(){}
 Fun.prototype.test=function(){}
 var fun=new Fun()
 fun.test()

 constructor指向原函数对象
 Fun.prototype.constructor===Fun

16 显式原型与隐式
 1每个函数function都有一个prototype,即是显式原型 属性
 2 每个实例对象都有一个 __proto__ 可称为隐式原型  属性
 3 对象的隐式原型的值为其对应构造函数的显式原型的值
 Fn.prototype===fn.__proto__
 4 内存结构
 5 函数prototype 属性 在定义函数时自动添加的 默认值是一个空object对象
   对象的__proto__属性 创建对象时自动添加的，默认值为构造函数的prototype属性值
   程序员能直接操作显式原型 但不能直接操作隐式原型 es6之前

17 原型链
 1原型链 图解
 访问一个对象的属性时
  先在自身属性中查找，找到返回
  如果没有，再沿着__proto__上找
  最终没有找到，返回undefined
 别名 隐式原型链
 作用 查找对象的属性 方法

 2构造函数/原型/实体对象的关系
  隐式原型指向显式
 3 构造函数/原型/实体对象的关系2

18补充
 1函数的显示原型指向的对象默认是空object实例对象  但object不满足
 Fn.prototype instanceof Object true
 Object.prototype instanceof Object false
 Function.prototype instanceof Object true

 2 所有函数都是Function的实例 包括Function
 Function.__proto__===Function.prototype

 Object的原型对象是原型链的尽头
 Object.prototype.__proto__  null

19 属性问题
 1读取对象的属性值 会自动到原型链中查找
 2设置对象属性值时 不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值
 3方法一般定义在原型中中，属性一般通过构造函数定义在对象本身上

20 探索instanceof
 1instanceof是如何判断的
 表达式 A instanceof B 
 如果B函数的显示原型对象在A对象的原型链上，返回true，否则返回false
 2 Function是通过new自己产生的实例

 Object instanceof Object true
 Function instanceof Function true
 Function instanceof Object true
 Object instanceof Function true
 function Foo(){}
 Object instanceof Foo false

21 原型 面试题
      function A(){

        }
        A.prototype.n=1
        var b=new A()
        A.prototype={
            n:2,
            m:3
        }
        var c=new A()
        console.log(b.n,b.m,c.n,c.m); //1 undefined 2 3


22 变量提升与函数
 1 变量声明提升
 通过var定义(声明)的变量,在定义语句之前就可以访问到
 值：undefined

 2函数声明提升
 通过function声明的函数，在之前就可以直接调用
 值：函数定义(对象)

 3 变量提升和函数提升是如何产生的

23 执行上下文
 1 全局代码 函数代码局部

 2全局执行上下文
 在执行全局代码前将window确定为全局执行上下文
 对全局数据进行预处理
 var定义的全局变量==>undefined 添加为window属性
 function声明的全局函数==>赋值(fun),添加为window方法
 this==>赋值(window)
 开始执行全局代码

 3 函数执行上下文
 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象
 对局部数据进行预处理
 形参变量==>赋值(实参)==>添加为指向上下文的属性
 arguments==>辅助(实参列表) 添加为执行上下文的属性   伪数组
 var定义的局部变量==>undefined 添加为执行上下文的属性
 function声明的函数==>赋值(fun) 添加为执行上下文的属性
 this==>赋值 调用函数的对象
 开始执行函数体代码

24 执行上下文栈
 1 在全局代码执行前 js引擎就会创建一个栈来存储管理所有的执行上下文对象
 2 在全局执行上下文(window)确定后 将其添加到栈中 压栈
 3 在函数执行完上下文创建后 将其添加到栈中
 4 在当前函数执行完后 将栈顶的对象移除 出栈
 5 当所有的代码执行完后 栈中只剩下window
 
25 面试题
 函数提升先 变量提升后 变量提升时不会覆盖同名变量
 但会被变量赋值后覆盖

26 复习

27 作用域与作用链
 1 理解
 就是一个地盘，一个代码段所在的区域

 2 分类
 全局作用域
 函数作用域
 没有块级作用域 es6有了

 3作用
 隔离变量 不同作用域下同名变量不会有冲突


 1区别
 全局作用域之外 每个函数都会创建自己的作用域 作用域在函数定义时就已经确定了，而不是在函数调用时
 全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建
 函数执行上下文环境是在调用函数 函数体代码执行之前创建

 2
 作用域是静态的 只要函数定义好了就一直存在 ，且不会再变化
 执行上下文是动态的，调用函数时创建，函数调用结束时上下文环境就会自动释放

 3 联系
 上下文环境(对象)是从属于所在的作用域
 全局上下文环绕==>全局作用域
 函数上下文环绕==>对应的函数使用域


 1理解
 多个上下级关系的作用域形成的链，它的方向是从下向上的(从内到外)
 查找变量时就是沿着作用域链来查找的

 2 查找一个变量的查找规则
 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入2
 在上一级作用域执行上下文中查找对应属性，有直接返回，否则进入3
 再次执行2的相同操作 直到全局作用域 找不到就抛出异常

28 作用域 面试
 查找变量可以直接xx 查找属性需要对应xx.xx

29 循环遍历加监听
 
30 闭包理解
 1 如何产生闭包
 当一个嵌套的内部(字)函数引用了嵌套的外部(父)函数的变量(函数)时,就产生了闭包

 2 闭包到底是什么
 使用chrome调试查看
 理解一 闭包是嵌套的内部函数
 理解二 包含被引用变量(函数)的对象(极少数人)
 注意:闭包存在于嵌套的内部函数中

 3 产生闭包的条件
 函数嵌套 
 内部函数引用了外部函数的数据(变量/函数)


 执行函数定义就好产生闭包  不用调用内部函数

31 常见的闭包
 1将函数作为另一个函数返回值
         function fn1(){
            var a=2
            function fn2(){
                a++
                console.log(a);
            }
            return fn2
  
        }
        var f=fn1()
        f()
        f()
 保存局部变量

 2将函数作为实参传递给另一个函数调用
         function showDelay(msg, time) {
            setTimeout(function () {
                alert(msg)
            }, time)
        }
        showDelay('atguigu', 2000)

32 闭包的作用
 1 使用函数内部的变量在函数执行完后，仍然存活在内存中 延长了局部变量的生命周期
 
 2 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

 1 函数执行完后，函数内部声明的局部变量是否还存在
  一般不在      还在是在闭包里 对像引用函数

 2 在函数外部都能直接访问函数内部
 不能 但是可以通过闭包让外部操作它

33 闭包的生命周期
 1产生 在嵌套内部函数定义执行完时就产生了(不是在调用)

 2 死亡 在嵌套的内部函数成为垃圾对象时
   f = null

34 闭包应用 自定义js模块
 具有特定功能的js模块
 将舍友的数据和功能都封装在一个函数内部(私有的)
 只向外暴露一个包含n个方法的对象或函数
 模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能
 
 return{
   xx:xx,
   xxx,xxx
 }

 (function(){
   function xxx(){

   }
   function xx(){

   }
   window.xxx={
     xx:xx,
     xxx:xxx
   }
 })()
 匿名函数 
 xxx.xxx

35 内存溢出与内存泄露
 1缺点
 函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
 容易造成内部泄露

 2 解决
 能不用闭包就不用
 及时释放

 1 内存溢出
 一种程序运行出现的错误
 当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误

 2 内存泄露 
 占用的内存没有及时释放
 内存泄露积累多了就任意导致溢出
 常见的内存泄露
  意外的全局变量
  没有及时清理计数器或回调函数
  闭包

36 面试题
 this谁调用就是谁
  var that = this
  通过that存储

37 对象创建模式
 方法一:Object构造函数模式
  套路:先创建空Object对象，再动态添加属性/方法
  适用场景:起始时不确定对象内部数据
  问题:语句太多

 方法二 对象字面量模式
  套路:使用{}创建对象 同时指定属性/方法
  适用场景：起始时对象内部数据是确定的
  问题:如果创建多个对象，有重复代码

  方法三 工厂模式
   套路：通过工厂函数动态创建对象并返回
   使用：需要创建多个对象
   问题：对象没有应该具体的类型，都是Object类型
   return
  var s=xxx()

   方法四 自定义构造函数模式
   套路：自定义构造函数，通过new创建对象
   适用场景：需要创建多个类型确定的对象
   问题：每过对象都有相同的数据浪费内存
   var p1=new Person()

   方法五 构造函数+原型的组合模式
   套路：自定义构造函数，属性在函数中初始化，方法添加到原型上
   适用场景：需要创建多个类型确定的对象
   xx.prototype.xx=function(xx){this.name=name}

38 原型链继承
 方式1 原型链继承
 1 套路 
  1 定义父类型构造函数
  2 给父类型的原型添加方法
  3 定义子类型的构造函数
  4 创建父类型的对象赋值给子类型的原型
  5 将子类型原型的构造属性设置为子类型
  6 给子类型原型添加方法
  7 创建子类型的对象：可以调用父类型的方法
 2 关键
  1 子类型的原型为父类型的应该实例对象

 Sub.prototype=new Supper()

39 组合继承
 让子类型的原型的constructor指向子类型
 Sub.prototype.constructor=Sub

 在子类型构造函数中通用call()调用父类型构造函数
 xx.call(this,xx,xx)=this.xx(xx,xx) 通过s调用
 var s=new xx()


 function Student(name,price){
   Person.call(this,name) 为了得到属性
   this.price=price
 }
 Student.prototype=new Person() 为了能够看到父类型的方法
 Student.prototype.constructor=Student 修正constructor属性

40 复习

41 闭包终极面试题

42 进程与线程
 进程process  程序执行一次，它占有一片独有的内存空间

 线程thread  是继承内的一个独立执行单元
  是程序指向的一个完整流程
  是cpu的最小调度单元


  应用程序必须运行在某个进程的某个线程上
  一个进程中至少有一个运行的线程：主线程，进程启动后自动创建
  一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的
  一个进程内的数据可以供其中的多个线程直接共享
  多个进程之间的数据是不能直接共享的
  线程池：保存多个线程对象的容器，实现线程对象的反复利用
  
43 浏览器内核
 支撑浏览器运行的最核心的程序
 不同浏览器不一样
 
 核由很多模块组成 
  主线程 
    js引擎模块：负责js程序的编译与运行
    html，css文档解析模块：负责页面文本的解析
    DOM/CSS模块：负责dom/css在内存的相关处理
    布局和渲染模块:负责页面的布局和效果的绘制(内存的对象)

  分线程
    定时器模块:负责定时器的管理
    事件响应模块：负责事件的管理
    网络请求模块:负责ajax请求

44 定时器引发
 1 定时器真是定时执行吗
  定时器并不能保证真正定时执行
  一般延长有点，也有可能延长很久

  2 定时器回调函数是在分线程执行的吗
  在主线程执行的，js是单线程的

  3 定时器是如何实现的
  事件循环模型

45 js是单线程执行的
 alert会暂停主线程的执行

 1如何证明js执行是单线程的
 setTimeout()的回调函数是在主线程执行的
 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行

 2 为什么js要用单线程模式，而不用多线程模式
 javaScript的单线程，与它的用途有关
 作为浏览器脚本语言，javaScript的主要用途是与用户互动，以及操作DOM
 这决定了它只能是单线程，否则会带来很复杂的同步问题

 3 代码的分类
 初始化代码
 回调函数

 4js引擎执行代码的基本流程
 先执行初始化代码：包含一些特别的代码
 设置定时器
 绑定监听
 发送ajax请求
 后面在某个时刻才会执行回调代码

46 事件循环模型
 1 所有代码分类
 初始化执行代码(同步代码):包含绑定dom事件监听，设置定时器，发送ajax请求的代码
 回调执行代码(异步代码)：处理回调逻辑

 2 js引擎执行代码的基本流程：
 初始化代码==>回调代码 

 3 模型的两个重要组成部分：
 事件管理模块 定时器/DOM事件/Ajax
 回调队列

 4模型的运转流程
 执行初始化代码，将事件回调函数交给对应模块管理
 当事件发生时，管理模块会将回调数及其数据添加到回调列队中
 只有当初始化代码执行完毕后(可能要一定时间)才会遍历读取回调队列中的回调函数执行

47 H5 Web Workers 多线程
 1 H5规范提供了js分线程的实现，取名为Web Workers

 2 相关API
 Worker:构造函数,加载分线程执行的js文件
 Worker.prototype.onmessage:用于接收另一个线程的回调函数
 Worker.prototype.postMessage:向另一个线程发送消息

 3 不足
  woreker内代码不能操作DOM(更新UI)
  不能跨域加载js
  不是每个浏览器都支撑新特性

48 复习




















